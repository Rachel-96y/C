// CrackMe_9_23_2023.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

/*

// LDR中所需类型的结构
typedef struct _UNICODE_STRING {
	USHORT Length;
	USHORT MaximumLength;
	PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

// PEB
typedef struct _PEB_LDR_DATA
{
	DWORD Length;
	bool Initialized;
	PVOID SsHandle;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA,*PPEB_LDR_DATA;

// LDR
typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	LIST_ENTRY InInitializationOrderLinks;
	PVOID DllBase;
	PVOID EntryPoint;
	UINT32 SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	UINT32 Flags;
	USHORT LoadCount;
	USHORT TlsIndex;
	LIST_ENTRY HashLinks;
	PVOID SectionPointer;
	UINT32 CheckSum;
	UINT32 TimeDateStamp;
	PVOID LoadedImports;
	PVOID EntryPointActivationContext;
	PVOID PatchInformation;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

BOOL ShellCode()
{
	// 声明需要的变量;

	LPBYTE pStr = NULL;
	LPWORD pFirst = NULL;
	LPWORD pLast = NULL;
	DWORD dwOrdinal = NULL;
	DWORD dwNameOrdinal = NULL;
	DWORD dwKernelBase = NULL;
	DWORD dwGetProcAddress = NULL;
	DWORD dwLoadLibraryA = NULL;
	DWORD dwMessageBox = NULL;
	PLDR_DATA_TABLE_ENTRY pPLD = NULL;
	PLDR_DATA_TABLE_ENTRY pBeg = NULL;
	LPDWORD PointerToNames = NULL;
	LPWORD PointerToNameOrdinals = NULL;
	LPDWORD PointerToFunctions = NULL;
	char szKernel32[] = {'K',0,'E',0,'R',0,'N',0,'E',0,'L',0,'3',0,'2',0,'.',0,'D',0,'L',0,'L',0,0,0}; // Unicode字符且必须大写	
	char szUser32[] = {'u','s','e','r','3','2','.','d','l','l',0};	
	char szGetProcAddress[] = {'G','e','t','P','r','o','c','A','d','d','r','e','s','s',0};	
	char szLoadLibrary[] = {'L','o','a','d','L','i','b','r','a','r','y','A',0};	
	char szMessageBox[] = {'M','e','s','s','a','g','e','B','o','x','A',0};	
	BYTE szBuffer1[] = {0xC7 ,0xEB ,0xB3 ,0xA2 ,0xCA ,0xD4 ,0xD0 ,0xDE ,0xB8 ,0xC4 ,0xD5 ,0xE2 ,0xC0 ,0xEF ,0xB5 ,0xC4 ,0xC4 ,0xDA ,0xC8 ,0xDD ,0x21 ,0x00};
	BYTE szBuffer2[] = {0xCC ,0xE1 ,0xCA ,0xBE ,0x21 ,0x00};
	LPBYTE pszGetProcAddress = (PBYTE)szGetProcAddress;
	
	// TEB -> PEB -> LDR
	__asm	
	{		
		mov eax,FS:[0x30] // PEB		
		mov eax,[eax+0x0C] // PEB->LDR		
		add eax,0x0C	// LDR->InLoadOrderModuleList		
		mov pBeg,eax		
		mov eax,[eax]		
		mov pPLD,eax	
	}
	// 对比字符串得到Kerner32.dll的模块句柄
	while (pPLD != pBeg)	
	{		
		pLast = (LPWORD)pPLD->BaseDllName.Buffer;		
		pFirst = (LPWORD)szKernel32;	
		while (*pFirst && *pLast == *pFirst)
			pFirst++,pLast++;
		if (*pFirst == *pLast)		
		{
			dwKernelBase = (DWORD)pPLD->DllBase;
			break;		
		}
		pPLD = (LDR_DATA_TABLE_ENTRY*)pPLD->InLoadOrderLinks.Flink;	
	}
	if (dwKernelBase == NULL) return -1;
	// 将Kerner32.dll模块句柄赋值结构体指针定位导出表
	PIMAGE_DOS_HEADER pPIMAGE_DOS_HEADER = (IMAGE_DOS_HEADER*)dwKernelBase;
	PIMAGE_NT_HEADERS32 pPIMAGE_NT_HEADERS32 = (IMAGE_NT_HEADERS32*)((DWORD)pPIMAGE_DOS_HEADER + pPIMAGE_DOS_HEADER -> e_lfanew);
	PIMAGE_FILE_HEADER pPIMAGE_FILE_HEADER = (IMAGE_FILE_HEADER*)((DWORD)pPIMAGE_NT_HEADERS32 + sizeof(pPIMAGE_NT_HEADERS32 -> Signature));
	PIMAGE_OPTIONAL_HEADER32 pPIMAGE_OPTIONAL_HEADER32 = (IMAGE_OPTIONAL_HEADER32*)((DWORD)pPIMAGE_FILE_HEADER + IMAGE_SIZEOF_FILE_HEADER); 
	PIMAGE_SECTION_HEADER pPIMAGE_SECTION_HEADER = (IMAGE_SECTION_HEADER*)((DWORD)pPIMAGE_OPTIONAL_HEADER32 + pPIMAGE_FILE_HEADER -> SizeOfOptionalHeader);
	PIMAGE_DATA_DIRECTORY pPIMAGE_DATA_DIRECTORY = (IMAGE_DATA_DIRECTORY*)(pPIMAGE_OPTIONAL_HEADER32 -> DataDirectory);
	PIMAGE_EXPORT_DIRECTORY pPIMAGE_EXPORT_DIRECTORY = (IMAGE_EXPORT_DIRECTORY*)(pPIMAGE_DATA_DIRECTORY -> VirtualAddress + dwKernelBase);
	// 对比找到GetProcAddress函数名称所在位置的下标
	PointerToNames = (LPDWORD)(pPIMAGE_EXPORT_DIRECTORY -> AddressOfNames + dwKernelBase);
	for (int i = 0; i < (int)pPIMAGE_EXPORT_DIRECTORY -> NumberOfNames; i++)
	{
		pStr = (LPBYTE)(*(PointerToNames + i) + dwKernelBase);
		while (*pStr && *pStr == *pszGetProcAddress)
			pStr++, pszGetProcAddress++;
		if (*pStr == *pszGetProcAddress)
		{
			dwOrdinal = i;
			break;
		}
		pszGetProcAddress = (PBYTE)szGetProcAddress;
	}
	// 根据函数名称下标在序号表中找到函数对应序号
	PointerToNameOrdinals = (LPWORD)(pPIMAGE_EXPORT_DIRECTORY -> AddressOfNameOrdinals + dwKernelBase);
	dwNameOrdinal = *(PointerToNameOrdinals + dwOrdinal);
	// 根据函数序号在地址表中找到对应函数地址
	PointerToFunctions = (LPDWORD)(pPIMAGE_EXPORT_DIRECTORY -> AddressOfFunctions + dwKernelBase);
	dwGetProcAddress = *(PointerToFunctions + dwNameOrdinal) + dwKernelBase;
	// 通过函数指针进行调用
	DWORD (WINAPI* pGetProcAddress)(HMODULE, LPCSTR) = (DWORD (WINAPI * )(HMODULE, LPCSTR))dwGetProcAddress;
	dwLoadLibraryA = (DWORD)pGetProcAddress((HINSTANCE)dwKernelBase, szLoadLibrary);
	HMODULE (WINAPI* pLoadLibraryA)(LPCSTR) = (HMODULE (WINAPI* )(LPCSTR))dwLoadLibraryA;
	dwMessageBox = pGetProcAddress(pLoadLibraryA(szUser32), szMessageBox);
	int (WINAPI* pMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT) = (int (WINAPI*)(HWND, LPCSTR, LPCSTR, UINT))dwMessageBox;
	pMessageBoxA(0, (LPCSTR)szBuffer1, (LPCSTR)szBuffer2, 0);

	return 0;
}

*/

#pragma comment(linker, "/subsystem:\"windows\" /entry:\"mainCRTStartup\"")

HANDLE g_hThread = NULL;
HANDLE g_hThreadCheck = NULL;

BYTE bShellCode[] = {
0x55, 0x8B, 0xEC, 0x81, 0xEC, 0x80, 0x00, 0x00, 0x00, 0xB0, 0x45, 0x53, 0x88, 0x45, 0x82, 0x88, 0x45, 0x88, 0x33, 0xDB, 0xB2, 0x73, 0xB1, 0x65, 0xB0, 0x72, 0x56, 0x57, 0x89, 0x5D, 0xF4, 0x89, 0x5D, 0xF8, 0x89, 0x5D, 0xFC, 0xC6, 0x45, 0x80, 0x4B, 0x88, 0x5D, 0x81, 0x88, 0x5D, 0x83, 0xC6, 0x45, 0x84, 0x52, 0x88, 0x5D, 0x85, 0xC6, 0x45, 0x86, 0x4E, 0x88, 0x5D, 0x87, 0x88, 0x5D, 0x89, 0xC6, 0x45, 0x8A, 0x4C, 0x88, 0x5D, 0x8B, 0xC6, 0x45, 0x8C, 0x33, 0x88, 0x5D, 0x8D, 0xC6, 0x45, 0x8E, 0x32, 0x88, 0x5D, 0x8F, 0xC6, 0x45, 0x90, 0x2E, 0x88, 0x5D, 0x91, 0xC6, 0x45, 0x92, 0x44, 0x88, 0x5D, 0x93, 0xC6, 0x45, 0x94, 0x4C, 0x88, 0x5D, 0x95, 0xC6, 0x45, 0x96, 0x4C, 0x88, 0x5D, 0x97, 0x88, 0x5D, 0x98, 0x88, 0x5D, 0x99, 0xC6, 0x45, 0xE0, 0x75, 0x88, 0x55, 0xE1, 0x88, 0x4D, 0xE2, 0x88, 0x45, 0xE3, 0xC6, 0x45, 0xE4, 0x33, 0xC6, 0x45, 0xE5, 0x32, 0xC6, 0x45, 0xE6, 0x2E, 0xC6, 0x45, 0xE7, 0x64, 0xC6, 0x45, 0xE8, 0x6C, 0xC6, 0x45, 0xE9, 
0x6C, 0x88, 0x5D, 0xEA, 0xC6, 0x45, 0xB4, 0x47, 0x88, 0x4D, 0xB5, 0xC6, 0x45, 0xB6, 0x74, 0xC6, 0x45, 0xB7, 0x50, 0x88, 0x45, 0xB8, 0xC6, 0x45, 0xB9, 0x6F, 0xC6, 0x45, 0xBA, 0x63, 0xC6, 0x45, 0xBB, 0x41, 0xC6, 0x45, 0xBC, 0x64, 0xC6, 0x45, 0xBD, 0x64, 0x88, 0x45, 0xBE, 0x88, 0x4D, 0xBF, 0x88, 0x55, 0xC0, 0x88, 0x55, 0xC1, 0x88, 0x5D, 0xC2, 0xC6, 0x45, 0xC4, 0x4C, 0xC6, 0x45, 0xC5, 0x6F, 0xC6, 0x45, 0xC6, 0x61, 0xC6, 0x45, 0xC7, 0x64, 0xC6, 0x45, 0xC8, 0x4C, 0xC6, 0x45, 0xC9, 0x69, 0xC6, 0x45, 0xCA, 0x62, 0x88, 0x45, 0xCB, 0xC6, 0x45, 0xCC, 0x61, 0x88, 0x45, 0xCD, 0xC6, 0x45, 0xCE, 0x79, 0xC6, 0x45, 0xCF, 0x41, 0x88, 0x5D, 0xD0, 0xC6, 0x45, 0xD4, 0x4D, 0x88, 0x4D, 0xD5, 0x88, 0x55, 0xD6, 0x88, 0x55, 0xD7, 0xC6, 0x45, 0xD8, 0x61, 0xB0, 0xC4, 0x88, 0x4D, 0xDA, 0x88, 0x45, 0xA5, 0x88, 0x45, 0xAB, 0x88, 0x45, 0xAC, 0xB1, 0xCA, 0xB0, 0x21, 0xC6, 0x45, 0xD9, 0x67, 0xC6, 0x45, 0xDB, 0x42, 0xC6, 0x45, 0xDC, 0x6F, 0xC6, 0x45, 
0xDD, 0x78, 0xC6, 0x45, 0xDE, 0x41, 0x88, 0x5D, 0xDF, 0xC6, 0x45, 0x9C, 0xC7, 0xC6, 0x45, 0x9D, 0xEB, 0xC6, 0x45, 0x9E, 0xB3, 0xC6, 0x45, 0x9F, 0xA2, 0x88, 0x4D, 0xA0, 0xC6, 0x45, 0xA1, 0xD4, 0xC6, 0x45, 0xA2, 0xD0, 0xC6, 0x45, 0xA3, 0xDE, 0xC6, 0x45, 0xA4, 0xB8, 0xC6, 0x45, 0xA6, 0xD5, 0xC6, 0x45, 0xA7, 0xE2, 0xC6, 0x45, 0xA8, 0xC0, 0xC6, 0x45, 0xA9, 0xEF, 0xC6, 0x45, 0xAA, 0xB5, 0xC6, 0x45, 0xAD, 0xDA, 0xC6, 0x45, 0xAE, 0xC8, 0xC6, 0x45, 0xAF, 0xDD, 0x88, 0x45, 0xB0, 0x88, 0x5D, 0xB1, 0xC6, 0x45, 0xEC, 0xCC, 0xC6, 0x45, 0xED, 0xE1, 0x88, 0x4D, 0xEE, 0xC6, 0x45, 0xEF, 0xBE, 0x88, 0x45, 0xF0, 0x88, 0x5D, 0xF1, 0x8D, 0x7D, 0xB4, 0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, 0x8B, 0x40, 0x0C, 0x83, 0xC0, 0x0C, 0x89, 0x45, 0xFC, 0x8B, 0x00, 0x89, 0x45, 0xF8, 0x8B, 0x75, 0xF8, 0x8B, 0x45, 0xFC, 0x3B, 0xF0, 0x74, 0x45, 0x66, 0x39, 0x5D, 0x80, 0x8B, 0x56, 0x30, 0x8D, 0x4D, 0x80, 0x74, 0x17, 0x8B, 0x45, 0x80, 0x66, 0x39, 0x02, 0x75, 
0x0F, 0x66, 0x8B, 0x41, 0x02, 0x83, 0xC1, 0x02, 0x83, 0xC2, 0x02, 0x66, 0x3B, 0xC3, 0x75, 0xEC, 0x66, 0x8B, 0x01, 0x66, 0x3B, 0x02, 0x74, 0x13, 0x8B, 0x36, 0x8B, 0x45, 0xFC, 0x3B, 0xF0, 0x75, 0xCC, 0x5F, 0x5E, 0x83, 0xC8, 0xFF, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x8B, 0x56, 0x18, 0x3B, 0xD3, 0x75, 0x0A, 0x5F, 0x5E, 0x83, 0xC8, 0xFF, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3, 0x8B, 0x4A, 0x3C, 0x89, 0x5D, 0xF8, 0x8B, 0x74, 0x11, 0x78, 0x8B, 0x4C, 0x16, 0x18, 0x03, 0xF2, 0x8B, 0x46, 0x20, 0x03, 0xC2, 0x3B, 0xCB, 0x7E, 0x47, 0x89, 0x45, 0xFC, 0x8B, 0x45, 0xFC, 0x8B, 0x00, 0x03, 0xC2, 0x8A, 0x08, 0x3A, 0xCB, 0x74, 0x0D, 0x3A, 0x0F, 0x75, 0x09, 0x8A, 0x48, 0x01, 0x40, 0x47, 0x3A, 0xCB, 0x75, 0xF3, 0x8A, 0x08, 0x8A, 0x07, 0x3A, 0xC8, 0x74, 0x1C, 0x8B, 0x4D, 0xFC, 0x8B, 0x45, 0xF8, 0x83, 0xC1, 0x04, 0x40, 0x89, 0x4D, 0xFC, 0x8B, 0x4E, 0x18, 0x3B, 0xC1, 0x8D, 0x7D, 0xB4, 0x89, 0x45, 0xF8, 0x7C, 0xC4, 0xEB, 0x06, 0x8B, 0x45, 0xF8, 0x89, 0x45, 
0xF4, 0x8B, 0x4E, 0x24, 0x8B, 0x45, 0xF4, 0x8D, 0x0C, 0x41, 0x33, 0xC0, 0x66, 0x8B, 0x04, 0x11, 0x8B, 0x4E, 0x1C, 0x8D, 0x04, 0x81, 0x8D, 0x4D, 0xC4, 0x51, 0x52, 0x8B, 0x34, 0x10, 0x03, 0xF2, 0xFF, 0xD6, 0x8D, 0x55, 0xD4, 0x8D, 0x4D, 0xE0, 0x52, 0x51, 0xFF, 0xD0, 0x50, 0xFF, 0xD6, 0x8D, 0x55, 0xEC, 0x53, 0x8D, 0x4D, 0x9C, 0x52, 0x51, 0x53, 0xFF, 0xD0, 0x5F, 0x5E, 0x33, 0xC0, 0x5B, 0x8B, 0xE5, 0x5D, 0xC3
};

DWORD WINAPI ThreadProc(LPVOID lpParameter)
{
	LPVOID pSpace = NULL;
	LPVOID pSpace2 = NULL;
	do
	{
		Sleep(1000);
		pSpace = malloc(0x2B0);
		if (!pSpace)
		{
			continue;
		}
		if (pSpace == pSpace2)
		{
			continue;
		}
		memset(pSpace, 0, 0x2B0);
		memcpy(pSpace, bShellCode, 0x2B0);
		pSpace2 = pSpace;
		BOOL (WINAPIV* pShellCode)() = (BOOL (WINAPIV* )())pSpace;
		pShellCode();
		free(pSpace);
	}
	while (TRUE);
	
	return 0;
}

DWORD WINAPI ThreadProcCheck(LPVOID lpParameter)
{
	do
	{
		Sleep(1000);
	}
	while (TRUE);
	
	return 0;
}

typedef struct _SHELLCODE
{
	_SHELLCODE()
	{
		g_hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL);
		g_hThreadCheck = CreateThread(NULL, 0, ThreadProcCheck, NULL, 0, NULL);
	}

} SHELLCODE, *PSHELLCODE;

SHELLCODE SshellCode;

int main(int argc, char* argv[])
{	
	WaitForSingleObject(g_hThread, INFINITE);
	return 0;
}